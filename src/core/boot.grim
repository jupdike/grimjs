// Built-in infix operators
#infixl 9 !! Index
#infixr 9 ^  Pow
#infixr 9 ** Pow
#infixl 7 *  Mul
#infixl 7 /  Div
#infixl 7 %  Mod
#infixl 6 +  Add
#infixl 6 -  Sub
#infixr 5 :  Pair
// concat and cons, following Haskell for concat, and Lean for cons
#infixr 5 ++ Concat
#infixr 5 :: Cons
#infixn 4 == Eq
#infixn 4 != Neq
#infixn 4 <  Lt
#infixn 4 <= LtEq
#infixn 4 >  Gt
#infixn 4 >= GtEq
#infixn 4 =  Equals
#infixr 3 && And
#infixr 2 || Or
#infixl 1 ?  If2
#infixl 0 @  LApply
#infixr 0 $  RApply

// Built-in casts so arithmetic works as expected
// and so we don't have to make N x M callable entries for Div, for Mul, etc.
Int :> Nat
Rat :> Int
Rat :> Nat
Dec :> Rat
Dec :> Int
Dec :> Nat

// Test some definitions of scalars and functions, in scope at the module level
fortyOne := 41
fortyTwo := add41(1)
// since they are functions, they should be able to call eachother,
// no matter the order in which they are defined
add41(x) := sum2(fortyOne, x)
// functions in a module are 'lifted' to the top, meaning they are evaluated first,
// so scalar definitions can call them
sum2 := (x, y) => x + y

sqrt(x) := x^0.5

fact(n) := if n <= 1 then 1 else n * fact(n - 1)

fib(n) := if n <= 1 then n else fib(n - 2) + fib(n - 1)
